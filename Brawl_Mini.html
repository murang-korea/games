<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Brawl Mini+</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    background: #1a1a1a;
    font-family: "Pretendard", sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-size: 1.1rem;
    z-index: 10;
  }
  canvas {
    background: #2e2e2e;
    border-radius: 10px;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="ui">‚ù§Ô∏è HP: <span id="hp">100</span></div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const player = { x: canvas.width / 2, y: canvas.height / 2, size: 20, color: "#4f8cff", hp: 100, bullets: [] };
const enemy = { 
  x: canvas.width / 4, 
  y: canvas.height / 3, 
  size: 20, 
  color: "#ff4f4f", 
  dirX: 1, dirY: 1, 
  bullets: [], 
  hp: 50, alive: true 
};

const keys = {};
let joystick = null;
let moveDir = {x:0,y:0};

// ÌÇ§Î≥¥Îìú Ïù¥Îèô
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => keys[e.key] = false);

// ÌÑ∞Ïπò Ï°∞Ïûë (ÏôºÏ™Ω: Ïù¥Îèô / Ïò§Î•∏Ï™Ω: Í≥µÍ≤©)
canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  if (t.clientX < window.innerWidth / 2) {
    joystick = {startX: t.clientX, startY: t.clientY};
  } else {
    fireBullet(t.clientX, t.clientY);
  }
});
canvas.addEventListener("touchmove", e => {
  if (joystick) {
    const t = e.touches[0];
    const dx = t.clientX - joystick.startX;
    const dy = t.clientY - joystick.startY;
    const len = Math.hypot(dx, dy);
    if (len > 0) {
      moveDir.x = dx / len;
      moveDir.y = dy / len;
    }
  }
});
canvas.addEventListener("touchend", e => {
  joystick = null;
  moveDir = {x:0,y:0};
});

function fireBullet(x, y) {
  const rect = canvas.getBoundingClientRect();
  const dx = x - rect.left - player.x;
  const dy = y - rect.top - player.y;
  const angle = Math.atan2(dy, dx);
  player.bullets.push({
    x: player.x,
    y: player.y,
    dx: Math.cos(angle) * 6,
    dy: Math.sin(angle) * 6
  });
}

setInterval(() => {
  if (!enemy.alive) return;
  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const angle = Math.atan2(dy, dx);
  enemy.bullets.push({
    x: enemy.x,
    y: enemy.y,
    dx: Math.cos(angle) * 4,
    dy: Math.sin(angle) * 4
  });
}, 1200);

function update() {
  const speed = Math.max(canvas.width, canvas.height) * 0.004;

  // ÌÇ§Î≥¥Îìú Ïù¥Îèô
  if (keys["ArrowUp"]) player.y -= speed;
  if (keys["ArrowDown"]) player.y += speed;
  if (keys["ArrowLeft"]) player.x -= speed;
  if (keys["ArrowRight"]) player.x += speed;

  // Ï°∞Ïù¥Ïä§Ìã± Ïù¥Îèô
  player.x += moveDir.x * speed;
  player.y += moveDir.y * speed;

  // Ï†Å Ïù¥Îèô (ÎûúÎç§)
  if (enemy.alive) {
    if (Math.random() < 0.02) enemy.dirX *= -1;
    if (Math.random() < 0.02) enemy.dirY *= -1;
    enemy.x += enemy.dirX * 2;
    enemy.y += enemy.dirY * 2;
  }

  handleWalls(player);
  handleWalls(enemy, true);
  moveBullets(player.bullets);
  moveBullets(enemy.bullets);
  checkHits();
  draw();
  requestAnimationFrame(update);
}

function handleWalls(obj, bounce = false) {
  const minX = obj.size;
  const maxX = canvas.width - obj.size;
  const minY = obj.size;
  const maxY = canvas.height - obj.size;
  if (obj.x < minX) { obj.x = minX; if (bounce) obj.dirX *= -1; }
  if (obj.x > maxX) { obj.x = maxX; if (bounce) obj.dirX *= -1; }
  if (obj.y < minY) { obj.y = minY; if (bounce) obj.dirY *= -1; }
  if (obj.y > maxY) { obj.y = maxY; if (bounce) obj.dirY *= -1; }
}

function moveBullets(bullets) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.dx;
    b.y += b.dy;
    if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height)
      bullets.splice(i, 1);
  }
}

function checkHits() {
  for (let i = player.bullets.length - 1; i >= 0; i--) {
    const b = player.bullets[i];
    if (enemy.alive && dist(b.x, b.y, enemy.x, enemy.y) < enemy.size) {
      player.bullets.splice(i, 1);
      enemy.hp -= 10;
      enemy.color = "#ff0000";
      setTimeout(() => (enemy.color = "#ff4f4f"), 150);
      if (enemy.hp <= 0) {
        enemy.alive = false;
        setTimeout(() => alert("üéâ ÏäπÎ¶¨! ÏÉàÎ°úÍ≥†Ïπ®ÏúºÎ°ú Ïû¨ÏãúÏûë!"), 100);
      }
    }
  }

  for (let i = enemy.bullets.length - 1; i >= 0; i--) {
    const b = enemy.bullets[i];
    if (dist(b.x, b.y, player.x, player.y) < player.size) {
      enemy.bullets.splice(i, 1);
      player.hp -= 10;
      document.getElementById("hp").textContent = player.hp;
      player.color = "#aaa";
      setTimeout(() => (player.color = "#4f8cff"), 150);
      if (player.hp <= 0) {
        alert("üíÄ Ìå®Î∞∞! ÏÉàÎ°úÍ≥†Ïπ®Ìï¥ÏÑú Îã§Ïãú ÏãúÏûë!");
        window.location.reload();
      }
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
  ctx.fill();

  if (enemy.alive) {
    ctx.fillStyle = enemy.color;
    ctx.beginPath();
    ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = "#fff";
    ctx.fillRect(enemy.x - 20, enemy.y - 30, 40, 6);
    ctx.fillStyle = "#f00";
    ctx.fillRect(enemy.x - 20, enemy.y - 30, (enemy.hp / 50) * 40, 6);
  }

  ctx.fillStyle = "white";
  drawBullets(player.bullets);
  ctx.fillStyle = "#ff6666";
  drawBullets(enemy.bullets);
}

function drawBullets(bullets) {
  for (const b of bullets) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

function dist(x1, y1, x2, y2) {
  return Math.hypot(x1 - x2, y1 - y2);
}

update();
</script>
</body>
</html>
