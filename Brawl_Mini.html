<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Brawl Mini</title>
<style>
  html,body{height:100%;margin:0;background:#111;display:flex;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;color:#fff}
  #wrap{position:relative;width:100%;height:100%}
  canvas{display:block; width:100%; height:100%; touch-action:none; background:#222; }
  #ui{position:absolute;left:12px;top:12px;z-index:20}
  #ui .hp{background:rgba(255,255,255,0.06);padding:6px 10px;border-radius:10px}
  .hint{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.04);padding:6px 10px;border-radius:10px;font-size:13px}
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game"></canvas>
    <div id="ui"><span class="hp">HP: <span id="hp">100</span></span></div>
    <div class="hint">ì™¼ìª½ ë“œë˜ê·¸: ì´ë™ Â· ì˜¤ë¥¸ìª½ ë“œë˜ê·¸ í›„ ë†“ê¸°: ë°œì‚¬</div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // --- í™”ë©´ ë§ì¶¤ ---
  function fit() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    W = canvas.width; H = canvas.height;
    generateWalls();
    placeEntitiesSafe();
  }
  let W = window.innerWidth, H = window.innerHeight;
  fit();
  window.addEventListener('resize', () => { fit(); });

  // --- ì—”í‹°í‹° ---
  const player = { x:0, y:0, r:20, color:'#4f8cff', hp:100, bullets:[] };
  const enemy  = { x:0, y:0, r:20, color:'#ff6b6b', hp:50, alive:true, bullets:[], dirX:1, dirY:1 };

  // --- ë§µ(ë²½) ---
  let walls = [];
  function rectsOverlap(a,b){
    return !(a.x + a.width <= b.x || b.x + b.width <= a.x || a.y + a.height <= b.y || b.y + b.height <= a.y);
  }
  function circleRectCollision(cx,cy,cr,rect){
    const nx = Math.max(rect.x, Math.min(cx, rect.x + rect.width));
    const ny = Math.max(rect.y, Math.min(cy, rect.y + rect.height));
    const dx = nx - cx, dy = ny - cy;
    return (dx*dx + dy*dy) <= (cr*cr);
  }

  function generateWalls(){
    walls = [];
    const area = W * H;
    const approxCount = Math.max(2, Math.floor(area / 120000)); // í™”ë©´ ë¹„ë¡€
    let triesOverall = 0;
    for(let i=0;i<approxCount;i++){
      let tries = 0;
      while(tries++ < 40 && triesOverall < 1000){
        triesOverall++;
        const ww = Math.max(60, Math.random() * Math.min(W*0.25, 300));
        const hh = 18 + Math.random()*40;
        const x = Math.random() * (W - ww);
        const y = Math.random() * (H - hh);
        const c = {x,y,width:ww,height:hh};
        let bad = false;
        for(const w of walls) if(rectsOverlap(w,c)){ bad = true; break; }
        // ì•ˆ ì¢‹ì€ ìœ„ì¹˜: ë„ˆë¬´ ì¤‘ì•™ ì¥ë²½ìœ¼ë¡œ ì „ì²´ ê°€ë¡œë§‰ì§€ ì•ŠìŒ
        if(!bad) { walls.push(c); break; }
      }
    }
  }

  function placeEntitiesSafe(){
    const triesMax = 300;
    // player (ì•„ë˜ì¤‘ì•™ ê·¼ì²˜)
    for(let t=0;t<triesMax;t++){
      const px = W * (0.5 + (Math.random()-0.5)*0.18);
      const py = H * (0.72 + (Math.random()-0.5)*0.12);
      const inside = walls.some(w => circleRectCollision(px,py,player.r+4,w));
      if(!inside){ player.x = px; player.y = py; break; }
      if(t===triesMax-1){ player.x = W*0.5; player.y = H*0.85; }
    }
    // enemy (ìœ„ì¤‘ì•™ ê·¼ì²˜)
    for(let t=0;t<triesMax;t++){
      const ex = W * (0.5 + (Math.random()-0.5)*0.18);
      const ey = H * (0.28 + (Math.random()-0.5)*0.12);
      const inside = walls.some(w => circleRectCollision(ex,ey,enemy.r+4,w));
      const tooClose = Math.hypot(ex-player.x, ey-player.y) < 120;
      if(!inside && !tooClose){ enemy.x = ex; enemy.y = ey; break; }
      if(t===triesMax-1){ enemy.x=W*0.5; enemy.y=H*0.15; }
    }
  }

  // ì´ˆê¸° ë§µ/ë°°ì¹˜
  generateWalls();
  placeEntitiesSafe();

  // --- ì…ë ¥ (ë“€ì–¼ìŠ¤í‹±) ---
  // pointers: map id -> { type: 'move'|'aim', id, sx, sy, x, y }
  const pointers = new Map();
  let movePointer = null, aimPointer = null;
  let moveVec = {x:0,y:0}, aimVec = {x:0,y:0};
  let fireCooldown = 0;

  function pointerAssign(id, cx){
    if(cx < W/2 && !movePointer){
      movePointer = { id, sx: cx, sy: lastYById.get(id) || (H*0.6), x:cx, y:lastYById.get(id) || (H*0.6) };
      pointers.set(id, movePointer);
      return movePointer;
    }
    if(cx >= W/2 && !aimPointer){
      aimPointer = { id, sx: cx, sy: lastYById.get(id) || (H*0.4), x:cx, y:lastYById.get(id) || (H*0.4) };
      pointers.set(id, aimPointer);
      return aimPointer;
    }
    // ignore extras
    return null;
  }

  // keep last Y for mouse mousedown start if needed
  const lastYById = new Map();

  // touch handlers
  canvas.addEventListener('touchstart', (ev) => {
    for(const t of ev.changedTouches){
      lastYById.set(t.identifier, t.clientY);
      pointerAssign(t.identifier, t.clientX);
    }
    ev.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchmove', (ev) => {
    for(const t of ev.changedTouches){
      const p = pointers.get(t.identifier);
      if(p){
        updatePointerMove(p, t.clientX, t.clientY);
      }
    }
    ev.preventDefault();
  }, { passive:false });

  canvas.addEventListener('touchend', (ev) => {
    for(const t of ev.changedTouches){
      const p = pointers.get(t.identifier);
      if(p){
        handlePointerEnd(p);
        pointers.delete(t.identifier);
      } else {
        // maybe it was unassigned; still clear lastY
        lastYById.delete(t.identifier);
      }
    }
    ev.preventDefault();
  }, { passive:false });

  // mouse support
  let mouseId = 'mouse';
  let mouseDown = false;
  canvas.addEventListener('mousedown', (ev) => {
    mouseDown = true;
    lastYById.set(mouseId, ev.clientY);
    pointerAssign(mouseId, ev.clientX);
    const p = pointers.get(mouseId) || (mouseId === (movePointer && movePointer.id) ? movePointer : aimPointer);
    if(p) updatePointerMove(p, ev.clientX, ev.clientY);
  });
  window.addEventListener('mousemove', (ev) => {
    if(!mouseDown) return;
    const p = pointers.get(mouseId);
    if(p) updatePointerMove(p, ev.clientX, ev.clientY);
  });
  window.addEventListener('mouseup', (ev) => {
    if(!mouseDown) return;
    const p = pointers.get(mouseId);
    if(p){ handlePointerEnd(p); pointers.delete(mouseId); }
    mouseDown = false;
  });

  function updatePointerMove(p, cx, cy){
    // limit radius
    const dx = cx - p.sx, dy = cy - p.sy;
    const limit = Math.min(90, Math.max(40, Math.min(W,H)*0.06));
    const dist = Math.hypot(dx,dy);
    const r = dist > limit ? limit / dist : 1;
    p.x = p.sx + dx * r;
    p.y = p.sy + dy * r;
    if(p === movePointer){
      moveVec = { x: (p.x - p.sx) / limit, y: (p.y - p.sy) / limit };
    } else if(p === aimPointer){
      aimVec = { x: (p.x - p.sx) / limit, y: (p.y - p.sy) / limit };
    }
  }

  function handlePointerEnd(p){
    if(p === aimPointer){
      const mag = Math.hypot(aimVec.x, aimVec.y);
      if(mag > 0.25 && fireCooldown <= 0){
        shoot(aimVec.x, aimVec.y);
        fireCooldown = Math.max(10, Math.round(0.28 * 60)); // í”„ë ˆì„ ë‹¨ìœ„ ì¿¨ë‹¤ìš´
      }
      aimPointer = null; aimVec = {x:0,y:0};
    } else if(p === movePointer){
      movePointer = null; moveVec = {x:0,y:0};
    }
  }

  // --- ë°œì‚¬ ---
  function shoot(dx,dy){
    const mag = Math.hypot(dx,dy);
    if(mag === 0) return;
    const angle = Math.atan2(dy,dx);
    const speed = Math.max(6, Math.min(12, Math.max(W,H) * 0.007));
    player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle)*speed, dy: Math.sin(angle)*speed, r:6 });
  }

  // --- ì  AI ë°œì‚¬ ---
  setInterval(() => {
    if(!enemy.alive) return;
    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const a = Math.atan2(dy,dx);
    enemy.bullets.push({ x: enemy.x, y: enemy.y, dx: Math.cos(a)*4.2, dy: Math.sin(a)*4.2, r:5 });
  }, 1200 + Math.random()*400);

  // --- ë²½ ì¶©ëŒ ìœ í‹¸ ---
  function pushOutOfWalls(entity){
    // ë°˜ë³µì ìœ¼ë¡œ ë³´ì • (ê°„ë‹¨í•œ í•´ê²°)
    for(let k=0;k<4;k++){
      for(const w of walls){
        if(circleRectCollision(entity.x, entity.y, entity.r, w)){
          // find nearest point
          const nx = Math.max(w.x, Math.min(entity.x, w.x + w.width));
          const ny = Math.max(w.y, Math.min(entity.y, w.y + w.height));
          let dx = entity.x - nx, dy = entity.y - ny;
          let d = Math.hypot(dx,dy);
          if(d < 0.001){ // center: push away by minimal vector
            dx = (entity.x > w.x + w.width/2) ? 1 : -1;
            dy = (entity.y > w.y + w.height/2) ? 1 : -1;
            d = Math.hypot(dx,dy);
          }
          const overlap = entity.r - d + 0.5;
          if(overlap > 0){
            entity.x += (dx/d) * overlap;
            entity.y += (dy/d) * overlap;
          }
        }
      }
    }
  }

  function bulletHitsWall(b){
    for(const w of walls){
      if(b.x > w.x && b.x < w.x + w.width && b.y > w.y && b.y < w.y + w.height) return true;
    }
    return false;
  }

  // --- ê²Œì„ ë£¨í”„ ---
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function update(){
    // movement
    const speed = Math.max(W,H) * 0.0035;
    player.x += moveVec.x * speed * 5;
    player.y += moveVec.y * speed * 5;

    // enemy wandering
    if(enemy.alive){
      if(Math.random() < 0.015) enemy.dirX *= -1;
      if(Math.random() < 0.015) enemy.dirY *= -1;
      enemy.x += enemy.dirX * 1.6;
      enemy.y += enemy.dirY * 1.6;
    }

    // clamp bounds
    player.x = clamp(player.x, player.r, W - player.r);
    player.y = clamp(player.y, player.r, H - player.r);
    enemy.x = clamp(enemy.x, enemy.r, W - enemy.r);
    enemy.y = clamp(enemy.y, enemy.r, H - enemy.r);

    // prevent stuck in wall
    pushOutOfWalls(player);
    pushOutOfWalls(enemy);

    // move bullets
    moveBullets(player.bullets);
    moveBullets(enemy.bullets);

    // bullet hits
    handleBulletHits();

    // cooldown tick
    if(fireCooldown > 0) fireCooldown--;

    draw();

    requestAnimationFrame(update);
  }

  function moveBullets(list){
    for(let i=list.length-1;i>=0;i--){
      const b = list[i];
      b.x += b.dx; b.y += b.dy;
      // remove if out of bounds or hits wall
      if(b.x < -60 || b.x > W + 60 || b.y < -60 || b.y > H + 60 || bulletHitsWall(b)){
        list.splice(i,1);
      }
    }
  }

  function handleBulletHits(){
    // player -> enemy
    for(let i=player.bullets.length-1;i>=0;i--){
      const b = player.bullets[i];
      if(enemy.alive && Math.hypot(b.x - enemy.x, b.y - enemy.y) < (b.r + enemy.r)){
        player.bullets.splice(i,1);
        enemy.hp -= 10;
        if(enemy.hp <= 0){ enemy.alive = false; setTimeout(()=>{ alert('ğŸ‰ ìŠ¹ë¦¬! ìƒˆë¡œê³ ì¹¨í•˜ë©´ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤.'); }, 80); }
      }
    }
    // enemy -> player
    for(let i=enemy.bullets.length-1;i>=0;i--){
      const b = enemy.bullets[i];
      if(Math.hypot(b.x - player.x, b.y - player.y) < (b.r + player.r)){
        enemy.bullets.splice(i,1);
        player.hp -= 10;
        document.getElementById('hp').textContent = player.hp;
        if(player.hp <= 0){ setTimeout(()=>{ alert('ğŸ’€ íŒ¨ë°°! ìƒˆë¡œê³ ì¹¨í•˜ì„¸ìš”.'); location.reload(); }, 80); }
      }
    }
  }

  // --- ê·¸ë¦¬ê¸° ---
  function draw(){
    ctx.clearRect(0,0,W,H);

    // walls
    ctx.fillStyle = '#444';
    for(const w of walls){
      ctx.fillRect(Math.round(w.x), Math.round(w.y), Math.round(w.width), Math.round(w.height));
    }

    // enemy
    if(enemy.alive){
      ctx.fillStyle = enemy.color;
      ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI*2); ctx.fill();
      // hp bar
      ctx.fillStyle = '#fff'; ctx.fillRect(enemy.x - 25, enemy.y - enemy.r - 18, 50, 6);
      ctx.fillStyle = '#f33'; ctx.fillRect(enemy.x - 25, enemy.y - enemy.r - 18, 50 * Math.max(0, enemy.hp)/50, 6);
    }

    // player
    ctx.fillStyle = player.color;
    ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();

    // bullets
    ctx.fillStyle = '#fff';
    for(const b of player.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
    ctx.fillStyle = '#ffb3b3';
    for(const b of enemy.bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

    // draw sticks visuals
    if(movePointer){
      drawStick(movePointer);
    }
    if(aimPointer){
      drawStick(aimPointer);
    }

    // cooldown indicator
    if(fireCooldown > 0){
      const perc = fireCooldown / Math.max(1, Math.round(0.28*60));
      const x = W - 70, y = H - 70;
      ctx.globalAlpha = 0.5;
      ctx.beginPath(); ctx.arc(x,y,36,0,Math.PI*2); ctx.fillStyle='#444'; ctx.fill();
      ctx.globalAlpha = 1;
      ctx.beginPath(); ctx.arc(x,y,30,-Math.PI/2, -Math.PI/2 + Math.PI*2*(1-perc)); ctx.strokeStyle='#999'; ctx.lineWidth=6; ctx.stroke();
      ctx.fillStyle='#fff'; ctx.font='13px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('CD', x, y);
    }
  }

  function drawStick(s){
    ctx.globalAlpha = 0.32;
    ctx.fillStyle = '#888';
    ctx.beginPath(); ctx.arc(s.sx, s.sy, 44, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#ccc';
    ctx.beginPath(); ctx.arc(s.x, s.y, 28, 0, Math.PI*2); ctx.fill();
  }

  // --- ì‹œì‘ ì„¸íŒ… ---
  // ensure entities placed after initial wall gen
  placeEntitiesSafe();
  // seed player hp shown
  document.getElementById('hp').textContent = player.hp;
  // start loop
  requestAnimationFrame(update);

  // expose global for debugging (optional)
  window._brawl = { player, enemy, walls };
})();
</script>
</body>
</html>
