<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Brawl Mini</title>
<style>
  html, body {
    margin: 0;
    overflow: hidden;
    background: #1e1e2f;
    touch-action: none;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: #282845;
  }
  .joystick {
    position: fixed;
    bottom: 80px;
    left: 80px;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: rgba(255,255,255,0.1);
    touch-action: none;
  }
  .stick {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    position: absolute;
    left: 30px;
    top: 30px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="joystick" id="joystick">
  <div class="stick" id="stick"></div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 50;
const ROWS = 12;
const COLS = 20;

// 맵 생성 (벽 1, 길 0)
let map = [];
function generateMap() {
  map = [];
  for (let y = 0; y < ROWS; y++) {
    const row = [];
    for (let x = 0; x < COLS; x++) {
      if (x === 0 || y === 0 || x === COLS-1 || y === ROWS-1) row.push(1);
      else if (Math.random() < 0.2) row.push(1);
      else row.push(0);
    }
    map.push(row);
  }
}
generateMap();

// 플레이어와 적
const player = { x: 5, y: 5, hp: 100 };
let enemy = { x: 15, y: 8, hp: 100 };

// 벽에 스폰된 적 재배치
while (map[Math.floor(enemy.y)][Math.floor(enemy.x)] === 1) {
  enemy.x = Math.floor(Math.random() * COLS);
  enemy.y = Math.floor(Math.random() * ROWS);
}

// A* 길찾기
function findPath(start, end) {
  const openSet = [start];
  const closedSet = [];
  const cameFrom = {};
  const gScore = {};
  const fScore = {};
  const key = (x, y) => `${x},${y}`;

  function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
  }

  gScore[key(start.x, start.y)] = 0;
  fScore[key(start.x, start.y)] = heuristic(start, end);

  while (openSet.length > 0) {
    openSet.sort((a, b) => fScore[key(a.x, a.y)] - fScore[key(b.x, b.y)]);
    const current = openSet.shift();

    if (current.x === end.x && current.y === end.y) {
      const path = [];
      let curKey = key(current.x, current.y);
      while (cameFrom[curKey]) {
        const [cx, cy] = curKey.split(",").map(Number);
        path.unshift({x: cx, y: cy});
        curKey = cameFrom[curKey];
      }
      return path;
    }

    closedSet.push(current);
    const neighbors = [
      {x: current.x+1, y: current.y},
      {x: current.x-1, y: current.y},
      {x: current.x, y: current.y+1},
      {x: current.x, y: current.y-1}
    ];

    for (let n of neighbors) {
      if (n.x < 0 || n.x >= COLS || n.y < 0 || n.y >= ROWS) continue;
      if (map[n.y][n.x] === 1) continue;
      if (closedSet.find(c => c.x === n.x && c.y === n.y)) continue;

      const tentativeG = gScore[key(current.x, current.y)] + 1;
      if (!openSet.find(o => o.x === n.x && o.y === n.y)) openSet.push(n);
      else if (tentativeG >= gScore[key(n.x, n.y)]) continue;

      cameFrom[key(n.x, n.y)] = key(current.x, current.y);
      gScore[key(n.x, n.y)] = tentativeG;
      fScore[key(n.x, n.y)] = gScore[key(n.x, n.y)] + heuristic(n, end);
    }
  }
  return [];
}

// 조이스틱
const joystick = document.getElementById("joystick");
const stick = document.getElementById("stick");
let move = {x: 0, y: 0};
let dragging = false;

joystick.addEventListener("touchstart", e => {
  dragging = true;
});
joystick.addEventListener("touchmove", e => {
  if (!dragging) return;
  const touch = e.touches[0];
  const rect = joystick.getBoundingClientRect();
  const dx = touch.clientX - (rect.left + rect.width/2);
  const dy = touch.clientY - (rect.top + rect.height/2);
  const dist = Math.min(Math.hypot(dx, dy), 40);
  const angle = Math.atan2(dy, dx);
  stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
  move.x = Math.cos(angle) * (dist / 40);
  move.y = Math.sin(angle) * (dist / 40);
});
joystick.addEventListener("touchend", () => {
  dragging = false;
  stick.style.transform = `translate(0, 0)`;
  move = {x:0, y:0};
});

function update() {
  // 플레이어 이동
  const newX = player.x + move.x * 0.1;
  const newY = player.y + move.y * 0.1;
  if (map[Math.floor(newY)][Math.floor(newX)] === 0) {
    player.x = newX;
    player.y = newY;
  }

  // 적 이동 (A*로)
  const path = findPath(
    {x: Math.floor(enemy.x), y: Math.floor(enemy.y)},
    {x: Math.floor(player.x), y: Math.floor(player.y)}
  );
  if (path.length > 0) {
    const next = path[0];
    const nx = next.x - enemy.x;
    const ny = next.y - enemy.y;
    enemy.x += nx * 0.05;
    enemy.y += ny * 0.05;
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const offsetX = canvas.width/2 - player.x*TILE;
  const offsetY = canvas.height/2 - player.y*TILE;

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (map[y][x] === 1) {
        ctx.fillStyle = "#3c3c5c";
        ctx.fillRect(x*TILE + offsetX, y*TILE + offsetY, TILE, TILE);
      }
    }
  }

  // 플레이어
  ctx.fillStyle = "#4af";
  ctx.beginPath();
  ctx.arc(player.x*TILE + offsetX, player.y*TILE + offsetY, 15, 0, Math.PI*2);
  ctx.fill();

  // 적
  ctx.fillStyle = "#f55";
  ctx.beginPath();
  ctx.arc(enemy.x*TILE + offsetX, enemy.y*TILE + offsetY, 15, 0, Math.PI*2);
  ctx.fill();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
