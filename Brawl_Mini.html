<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Brawl Mini</title>
<style>
  * { box-sizing: border-box; touch-action: none; }
  body, html { margin:0; padding:0; overflow:hidden; background:#111; height:100%; }
  canvas { display:block; background:#1c1c1c; }
  .joystick {
    width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,0.08); position:absolute;
    pointer-events:auto;
  }
  .stick {
    width:60px; height:60px; border-radius:50%;
    background:rgba(255,255,255,0.4); position:absolute;
    left:30px; top:30px; transition:0.05s;
  }
  #moveJoy { left:10px; bottom:10px; }
  #fireJoy { right:10px; bottom:10px; }
  #hpBar {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    width:60%; height:10px; background:#333; border-radius:5px;
  }
  #hpBar div {
    height:100%; width:100%; background:limegreen; border-radius:5px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hpBar"><div id="hpFill"></div></div>
<div id="moveJoy" class="joystick"><div class="stick" id="moveStick"></div></div>
<div id="fireJoy" class="joystick"><div class="stick" id="fireStick"></div></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let W, H;
function resize() { W = window.innerWidth; H = window.innerHeight; canvas.width=W; canvas.height=H; }
window.addEventListener("resize", resize); resize();

const player = { x:0, y:0, r:20, speed:4, hp:100, cd:0 };
const enemy = { x:0, y:-800, r:22, hp:100, cd:0 };
const bullets = [], enemyBullets = [];
let cameraY = 0;

// 일정한 벽 맵
const walls = [];
for (let i=0;i<10;i++){
  let offset = i*200;
  walls.push({x:-150,y:-offset-400,w:300,h:30});
  walls.push({x:-300,y:-offset-100,w:100,h:30});
  walls.push({x:200,y:-offset-250,w:100,h:30});
}

// 조이스틱 클래스
class Joystick {
  constructor(base, stick){
    this.base=base; this.stick=stick;
    this.value={x:0,y:0}; this.touchId=null;
    base.addEventListener("touchstart",e=>this.start(e));
    base.addEventListener("touchmove",e=>this.move(e));
    base.addEventListener("touchend",e=>this.end(e));
  }
  start(e){ const t=e.changedTouches[0]; this.touchId=t.identifier; this.update(t); }
  move(e){ const t=[...e.changedTouches].find(t=>t.identifier===this.touchId); if(t)this.update(t); }
  update(t){
    const rect=this.base.getBoundingClientRect();
    const cx=rect.left+rect.width/2, cy=rect.top+rect.height/2;
    const dx=t.clientX-cx, dy=t.clientY-cy;
    const dist=Math.min(40,Math.hypot(dx,dy));
    const ang=Math.atan2(dy,dx);
    this.stick.style.left=30+dist*Math.cos(ang)+"px";
    this.stick.style.top=30+dist*Math.sin(ang)+"px";
    this.value={x:dx/40,y:dy/40};
  }
  end(e){
    const t=[...e.changedTouches].find(t=>t.identifier===this.touchId);
    if(!t)return; this.touchId=null;
    this.stick.style.left="30px"; this.stick.style.top="30px";
    this.value={x:0,y:0};
  }
}
const moveJoy = new Joystick(document.getElementById("moveJoy"),document.getElementById("moveStick"));
const fireJoy = new Joystick(document.getElementById("fireJoy"),document.getElementById("fireStick"));

// 총알 생성
function shoot(x,y,ang,arr,speed=8){
  arr.push({x,y,dx:Math.cos(ang)*speed,dy:Math.sin(ang)*speed,life:90});
}

// 충돌 감지
function circleRect(px,py,pr,rx,ry,rw,rh){
  const cx=Math.max(rx,Math.min(px,rx+rw));
  const cy=Math.max(ry,Math.min(py,ry+rh));
  return Math.hypot(px-cx,py-cy)<pr;
}

// 루프
function loop(){
  ctx.clearRect(0,0,W,H);

  // 이동
  player.x += moveJoy.value.x * player.speed;
  player.y += moveJoy.value.y * player.speed;
  
  // 벽 충돌
  for(const w of walls){
    if(circleRect(player.x,player.y,player.r,w.x,w.y,w.w,w.h)){
      if(player.y>w.y) player.y=w.y+w.h+player.r;
      else player.y=w.y-player.r;
    }
  }

  // 카메라 따라가기
  cameraY = player.y + 200;

  // 발사
  if((fireJoy.value.x||fireJoy.value.y)&&player.cd<=0){
    const ang=Math.atan2(fireJoy.value.y,fireJoy.value.x);
    shoot(player.x,player.y,ang,bullets);
    player.cd=20;
  }
  if(player.cd>0)player.cd--;

  // 총알 이동
  for(const b of bullets){ b.x+=b.dx; b.y+=b.dy; b.life--; }
  for(const b of enemyBullets){ b.x+=b.dx; b.y+=b.dy; b.life--; }
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(b.life<=0) bullets.splice(i,1);
    if(Math.hypot(b.x-enemy.x,b.y-enemy.y)<enemy.r+4){
      enemy.hp-=10; bullets.splice(i,1);
    }
  }
  for(let i=enemyBullets.length-1;i>=0;i--){
    const b=enemyBullets[i];
    if(b.life<=0) enemyBullets.splice(i,1);
    if(Math.hypot(b.x-player.x,b.y-player.y)<player.r+4){
      player.hp-=10; enemyBullets.splice(i,1);
    }
  }

  // 적 AI
  const angToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
  enemy.x += Math.cos(angToPlayer)*2;
  enemy.y += Math.sin(angToPlayer)*2;
  if(enemy.cd<=0){
    shoot(enemy.x,enemy.y,angToPlayer,enemyBullets,6);
    enemy.cd=40;
  }
  enemy.cd--;

  // --- Draw ---
  ctx.save();
  ctx.translate(W/2 - player.x, H/2 - cameraY);

  // 배경 맵
  ctx.fillStyle="#222";
  ctx.fillRect(-600,-1600,1200,1600);

  // 벽
  ctx.fillStyle="#444";
  for(const w of walls) ctx.fillRect(w.x,w.y,w.w,w.h);

  // 플레이어
  ctx.fillStyle="deepskyblue";
  ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();

  // 적
  ctx.fillStyle="crimson";
  ctx.beginPath(); ctx.arc(enemy.x,enemy.y,enemy.r,0,Math.PI*2); ctx.fill();

  // 총알
  ctx.fillStyle="yellow";
  for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); }
  ctx.fillStyle="orange";
  for(const b of enemyBullets){ ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); }

  ctx.restore();

  // HP Bar
  document.getElementById("hpFill").style.width = player.hp + "%";

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
