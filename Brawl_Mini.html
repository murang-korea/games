<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Brawl Mini</title>
<style>
  body { margin:0; overflow:hidden; background:#111; touch-action:none; }
  canvas { display:block; background:#222; }
  .joystick {
    position:fixed;
    width:120px; height:120px;
    border-radius:50%;
    background:rgba(255,255,255,0.08);
    border:2px solid rgba(255,255,255,0.2);
    touch-action:none; z-index:10;
  }
  .stick {
    position:absolute;
    width:50px; height:50px;
    background:rgba(255,255,255,0.3);
    border-radius:50%;
    left:35px; top:35px;
  }
  #moveJoy { left:30px; bottom:30px; }
  #aimJoy { right:30px; bottom:30px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="moveJoy" class="joystick"><div class="stick"></div></div>
<div id="aimJoy" class="joystick"><div class="stick"></div></div>

<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
let W=innerWidth,H=innerHeight;
canvas.width=W;canvas.height=H;

// ====== 기본 설정 ======
const player={x:0,y:0,r:20,hp:100,reload:0};
const enemy={x:300,y:-400,r:20,hp:100,reload:0,angle:0,avoid:false,avoidTimer:0};
const bullets=[],eBullets=[];
let moveVec={x:0,y:0},aimVec={x:0,y:0};
let gameOver=false;

// ====== 맵 생성 ======
const mapWidth=1200,mapHeight=1800;
const walls=[];
const cell=100;
for(let y=-mapHeight/2;y<mapHeight/2;y+=cell){
  for(let x=-mapWidth/2;x<mapWidth/2;x+=cell){
    if(Math.random()<0.25&&Math.abs(x)>100&&Math.abs(y)>200)
      walls.push({x,y,w:cell-10,h:cell-10});
  }
}

// ====== 조이스틱 ======
function setupJoystick(id,cb){
  const joy=document.getElementById(id);
  const stick=joy.querySelector('.stick');
  let active=false,touchId=null,start={x:0,y:0};
  joy.addEventListener('touchstart',e=>{
    for(const t of e.changedTouches){
      if(!active){active=true;touchId=t.identifier;start.x=t.clientX;start.y=t.clientY;}
    }
  });
  joy.addEventListener('touchmove',e=>{
    if(!active)return;
    for(const t of e.changedTouches){
      if(t.identifier===touchId){
        const dx=t.clientX-start.x,dy=t.clientY-start.y;
        const dist=Math.min(40,Math.hypot(dx,dy));
        const ang=Math.atan2(dy,dx);
        stick.style.left=35+dist*Math.cos(ang)+'px';
        stick.style.top=35+dist*Math.sin(ang)+'px';
        cb(Math.cos(ang)*dist/40,Math.sin(ang)*dist/40);
      }
    }
  });
  joy.addEventListener('touchend',e=>{
    for(const t of e.changedTouches){
      if(t.identifier===touchId){
        active=false;touchId=null;
        stick.style.left='35px';stick.style.top='35px';
        cb(0,0);
      }
    }
  });
}
setupJoystick('moveJoy',(x,y)=>moveVec={x,y});
setupJoystick('aimJoy',(x,y)=>aimVec={x,y});

// ====== 충돌 ======
function collideCircleRect(c,r){
  let testX=c.x,testY=c.y;
  if(c.x<r.x-r.w/2)testX=r.x-r.w/2;
  else if(c.x>r.x+r.w/2)testX=r.x+r.w/2;
  if(c.y<r.y-r.h/2)testY=r.y-r.h/2;
  else if(c.y>r.y+r.h/2)testY=r.y+r.h/2;
  const dx=c.x-testX,dy=c.y-testY;
  return(dx*dx+dy*dy)<(c.r*c.r);
}

function checkWall(x,y){
  for(const w of walls)
    if(collideCircleRect({x,y,r:enemy.r},w))return true;
  return false;
}

// ====== 업데이트 ======
function update(){
  if(gameOver)return;
  const speed=3;
  const nextX=player.x+moveVec.x*speed;
  const nextY=player.y+moveVec.y*speed;
  let block=false;
  for(const w of walls)
    if(collideCircleRect({x:nextX,y:nextY,r:player.r},w))block=true;
  if(!block){
    player.x=clamp(nextX,-mapWidth/2+player.r,mapWidth/2-player.r);
    player.y=clamp(nextY,-mapHeight/2+player.r,mapHeight/2-player.r);
  }

  // ====== 발사 ======
  if((aimVec.x||aimVec.y)&&player.reload<=0){
    bullets.push({x:player.x,y:player.y,dx:aimVec.x*8,dy:aimVec.y*8});
    player.reload=20;
  }
  if(player.reload>0)player.reload--;

  // ====== 적 AI ======
  const dx=player.x-enemy.x,dy=player.y-enemy.y;
  const dist=Math.hypot(dx,dy);
  const moveSpeed=2;

  if(enemy.avoid){ // 회피 중
    enemy.avoidTimer--;
    enemy.x+=Math.cos(enemy.angle)*moveSpeed;
    enemy.y+=Math.sin(enemy.angle)*moveSpeed;
    if(enemy.avoidTimer<=0)enemy.avoid=false;
  } else {
    let dirAngle=Math.atan2(dy,dx);
    const testX=enemy.x+Math.cos(dirAngle)*40;
    const testY=enemy.y+Math.sin(dirAngle)*40;
    if(checkWall(testX,testY)){
      // 벽 있으면 방향 꺾기
      dirAngle+=Math.PI/2*(Math.random()<0.5?1:-1);
      enemy.avoid=true;
      enemy.avoidTimer=40+Math.random()*30;
      enemy.angle=dirAngle;
    } else {
      enemy.angle=dirAngle;
      enemy.x+=Math.cos(dirAngle)*moveSpeed;
      enemy.y+=Math.sin(dirAngle)*moveSpeed;
    }
  }

  // 맵 경계 제한
  enemy.x=clamp(enemy.x,-mapWidth/2+enemy.r,mapWidth/2-enemy.r);
  enemy.y=clamp(enemy.y,-mapHeight/2+enemy.r,mapHeight/2-enemy.r);

  // ====== 적 발사 ======
  if(enemy.reload<=0&&dist<600){
    eBullets.push({x:enemy.x,y:enemy.y,dx:(dx/dist)*6,dy:(dy/dist)*6});
    enemy.reload=50;
  }
  if(enemy.reload>0)enemy.reload--;

  // ====== 총알 이동 및 충돌 ======
  moveBullets(bullets,enemy);
  moveBullets(eBullets,player);

  if(player.hp<=0||enemy.hp<=0){
    gameOver=true;
    setTimeout(()=>alert(player.hp>0?"승리!":"패배..."),300);
  }
}

function moveBullets(arr,target){
  for(const b of arr){
    b.x+=b.dx;b.y+=b.dy;
    for(const w of walls)
      if(b.x>w.x-w.w/2&&b.x<w.x+w.w/2&&b.y>w.y-w.h/2&&b.y<w.y+w.h/2)b.dead=true;
    if((b.x-target.x)**2+(b.y-target.y)**2<target.r**2){
      target.hp-=10;b.dead=true;
    }
    if(b.x<-mapWidth/2||b.x>mapWidth/2||b.y<-mapHeight/2||b.y>mapHeight/2)
      b.dead=true;
  }
  arr.splice(0,arr.length,...arr.filter(b=>!b.dead));
}

function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

// ====== 그리기 ======
function draw(){
  ctx.clearRect(0,0,W,H);
  const camX=player.x,camY=player.y;
  ctx.save();ctx.translate(W/2-camX,H/2-camY);
  ctx.fillStyle="#333";
  ctx.fillRect(-mapWidth/2,-mapHeight/2,mapWidth,mapHeight);
  ctx.fillStyle="#444";
  for(const w of walls)ctx.fillRect(w.x-w.w/2,w.y-w.h/2,w.w,w.h);
  ctx.fillStyle="yellow";
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  ctx.fillStyle="red";
  for(const b of eBullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  ctx.fillStyle="red";ctx.beginPath();ctx.arc(enemy.x,enemy.y,enemy.r,0,Math.PI*2);ctx.fill();
  drawHp(enemy);
  ctx.fillStyle="lime";ctx.beginPath();ctx.arc(player.x,player.y,player.r,0,Math.PI*2);ctx.fill();
  drawHp(player);
  ctx.restore();
}

function drawHp(o){
  ctx.fillStyle="black";ctx.fillRect(o.x-20,o.y-30,40,6);
  ctx.fillStyle="lime";ctx.fillRect(o.x-20,o.y-30,40*(o.hp/100),6);
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();

window.addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});
</script>
</body>
</html>
