<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Brawl Mini</title>
<style>
  body {margin:0;overflow:hidden;background:#111;touch-action:none;}
  canvas {display:block;background:#222;}
  .joystick {
    position:fixed;width:120px;height:120px;
    border-radius:50%;background:rgba(255,255,255,0.08);
    border:2px solid rgba(255,255,255,0.2);touch-action:none;z-index:10;
  }
  .stick {position:absolute;width:50px;height:50px;background:rgba(255,255,255,0.3);border-radius:50%;left:35px;top:35px;}
  #moveJoy {left:30px;bottom:30px;}
  #aimJoy {right:30px;bottom:30px;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="moveJoy" class="joystick"><div class="stick"></div></div>
<div id="aimJoy" class="joystick"><div class="stick"></div></div>

<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
let W=innerWidth,H=innerHeight;
canvas.width=W;canvas.height=H;

// ===== 기본 설정 =====
const player={x:0,y:0,r:20,hp:100,reload:0};
const enemy={x:400,y:-300,r:20,hp:100,reload:0,mode:"patrol",target:{x:400,y:-300},angle:0};
const bullets=[],eBullets=[];
let moveVec={x:0,y:0},aimVec={x:0,y:0};
let gameOver=false;

// ===== 맵 =====
const mapWidth=1200,mapHeight=1800;
const walls=[];
const cell=100;
for(let y=-mapHeight/2;y<mapHeight/2;y+=cell){
  for(let x=-mapWidth/2;x<mapWidth/2;x+=cell){
    if(Math.random()<0.25&&Math.abs(x)>100&&Math.abs(y)>150)
      walls.push({x,y,w:cell-10,h:cell-10});
  }
}

// ===== 조이스틱 =====
function setupJoystick(id,cb){
  const joy=document.getElementById(id);
  const stick=joy.querySelector('.stick');
  let active=false,touchId=null,start={x:0,y:0};
  joy.addEventListener('touchstart',e=>{
    for(const t of e.changedTouches){
      if(!active){active=true;touchId=t.identifier;start.x=t.clientX;start.y=t.clientY;}
    }
  });
  joy.addEventListener('touchmove',e=>{
    if(!active)return;
    for(const t of e.changedTouches){
      if(t.identifier===touchId){
        const dx=t.clientX-start.x,dy=t.clientY-start.y;
        const dist=Math.min(40,Math.hypot(dx,dy));
        const ang=Math.atan2(dy,dx);
        stick.style.left=35+dist*Math.cos(ang)+'px';
        stick.style.top=35+dist*Math.sin(ang)+'px';
        cb(Math.cos(ang)*dist/40,Math.sin(ang)*dist/40);
      }
    }
  });
  joy.addEventListener('touchend',e=>{
    for(const t of e.changedTouches){
      if(t.identifier===touchId){
        active=false;touchId=null;
        stick.style.left='35px';stick.style.top='35px';
        cb(0,0);
      }
    }
  });
}
setupJoystick('moveJoy',(x,y)=>moveVec={x,y});
setupJoystick('aimJoy',(x,y)=>aimVec={x,y});

// ===== 유틸 =====
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
function collideCircleRect(c,r){
  let testX=c.x,testY=c.y;
  if(c.x<r.x-r.w/2)testX=r.x-r.w/2;
  else if(c.x>r.x+r.w/2)testX=r.x+r.w/2;
  if(c.y<r.y-r.h/2)testY=r.y-r.h/2;
  else if(c.y>r.y+r.h/2)testY=r.y+r.h/2;
  const dx=c.x-testX,dy=c.y-testY;
  return(dx*dx+dy*dy)<(c.r*c.r);
}
function checkWall(x,y,r){
  for(const w of walls)
    if(collideCircleRect({x,y,r},w))return true;
  return false;
}

// ===== 업데이트 =====
function update(){
  if(gameOver)return;
  const speed=3;
  const nextX=player.x+moveVec.x*speed;
  const nextY=player.y+moveVec.y*speed;
  let block=false;
  for(const w of walls)
    if(collideCircleRect({x:nextX,y:nextY,r:player.r},w))block=true;
  if(!block){
    player.x=clamp(nextX,-mapWidth/2+player.r,mapWidth/2-player.r);
    player.y=clamp(nextY,-mapHeight/2+player.r,mapHeight/2-player.r);
  }

  // ===== 플레이어 공격 =====
  if((aimVec.x||aimVec.y)&&player.reload<=0){
    bullets.push({x:player.x,y:player.y,dx:aimVec.x*8,dy:aimVec.y*8});
    player.reload=20;
  }
  if(player.reload>0)player.reload--;

  // ====== 적 AI ======
  const dx=player.x-enemy.x,dy=player.y-enemy.y;
  const dist=Math.hypot(dx,dy);
  const speedE=2;

  // 플레이어 감지
  const canSee=!checkWall(enemy.x+dx/2,enemy.y+dy/2,enemy.r)&&dist<500;
  if(canSee){enemy.mode="chase";enemy.target={x:player.x,y:player.y};}
  else if(enemy.mode==="chase")enemy.mode="patrol";

  if(enemy.mode==="patrol"){
    if(Math.hypot(enemy.x-enemy.target.x,enemy.y-enemy.target.y)<20){
      // 랜덤 위치로 이동
      enemy.target.x=enemy.x+(Math.random()-0.5)*600;
      enemy.target.y=enemy.y+(Math.random()-0.5)*600;
    }
  }

  const tx=enemy.target.x,ty=enemy.target.y;
  let ang=Math.atan2(ty-enemy.y,tx-enemy.x);
  const nx=enemy.x+Math.cos(ang)*speedE;
  const ny=enemy.y+Math.sin(ang)*speedE;

  if(!checkWall(nx,ny,enemy.r)){
    enemy.x=nx;enemy.y=ny;enemy.angle=ang;
  }else{
    // 벽 충돌 시 방향 살짝 틀기
    enemy.angle+=((Math.random()<0.5)?1:-1)*(Math.PI/4);
  }

  enemy.x=clamp(enemy.x,-mapWidth/2+enemy.r,mapWidth/2-enemy.r);
  enemy.y=clamp(enemy.y,-mapHeight/2+enemy.r,mapHeight/2-enemy.r);

  // ===== 적 공격 =====
  if(enemy.mode==="chase"&&enemy.reload<=0&&dist<500){
    eBullets.push({x:enemy.x,y:enemy.y,dx:(dx/dist)*6,dy:(dy/dist)*6});
    enemy.reload=50;
  }
  if(enemy.reload>0)enemy.reload--;

  moveBullets(bullets,enemy);
  moveBullets(eBullets,player);

  if(player.hp<=0||enemy.hp<=0){
    gameOver=true;
    setTimeout(()=>alert(player.hp>0?"승리!":"패배..."),300);
  }
}

function moveBullets(arr,target){
  for(const b of arr){
    b.x+=b.dx;b.y+=b.dy;
    for(const w of walls)
      if(b.x>w.x-w.w/2&&b.x<w.x+w.w/2&&b.y>w.y-w.h/2&&b.y<w.y+w.h/2)b.dead=true;
    if((b.x-target.x)**2+(b.y-target.y)**2<target.r**2){
      target.hp-=10;b.dead=true;
    }
    if(b.x<-mapWidth/2||b.x>mapWidth/2||b.y<-mapHeight/2||b.y>mapHeight/2)
      b.dead=true;
  }
  arr.splice(0,arr.length,...arr.filter(b=>!b.dead));
}

// ===== 그리기 =====
function draw(){
  ctx.clearRect(0,0,W,H);
  const camX=player.x,camY=player.y;
  ctx.save();ctx.translate(W/2-camX,H/2-camY);
  ctx.fillStyle="#333";
  ctx.fillRect(-mapWidth/2,-mapHeight/2,mapWidth,mapHeight);
  ctx.fillStyle="#444";
  for(const w of walls)ctx.fillRect(w.x-w.w/2,w.y-w.h/2,w.w,w.h);
  ctx.fillStyle="yellow";
  for(const b of bullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  ctx.fillStyle="red";
  for(const b of eBullets){ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();}
  ctx.fillStyle="red";ctx.beginPath();ctx.arc(enemy.x,enemy.y,enemy.r,0,Math.PI*2);ctx.fill();
  drawHp(enemy);
  ctx.fillStyle="lime";ctx.beginPath();ctx.arc(player.x,player.y,player.r,0,Math.PI*2);ctx.fill();
  drawHp(player);
  ctx.restore();
}

function drawHp(o){
  ctx.fillStyle="black";ctx.fillRect(o.x-20,o.y-30,40,6);
  ctx.fillStyle="lime";ctx.fillRect(o.x-20,o.y-30,40*(o.hp/100),6);
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();

window.addEventListener('resize',()=>{W=innerWidth;H=innerHeight;canvas.width=W;canvas.height=H;});
</script>
</body>
</html>
