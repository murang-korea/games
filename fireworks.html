<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>불꽃축제 — Fireworks</title>
<style>
  :root{
    --bg:#060612;
    --panel-bg: rgba(0,0,0,0.45);
    --accent: #ffd166;
    --muted: rgba(255,255,255,0.18);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Arial;color:#fff;overflow:hidden;-webkit-tap-highlight-color:transparent;}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(180deg,#03040a 0%, #071023 40%, #071023 100%);}
  .ui {
    position:fixed; left:12px; top:12px; right:12px; display:flex; gap:12px; justify-content:space-between; align-items:center; z-index:40;
    pointer-events:auto;
  }
  .panel {
    background:var(--panel-bg);
    padding:8px 10px; border-radius:10px; display:flex; gap:8px; align-items:center; backdrop-filter: blur(4px);
  }
  .btn {
    background:transparent; border:1px solid var(--muted); color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer;
    font-weight:600; font-size:14px;
  }
  .btn:active{ transform:translateY(1px); }
  .range { width:140px; }
  .label { font-size:13px; color:var(--muted); margin-right:6px; }
  .small { font-size:12px; padding:6px 8px; border-radius:6px; }
  .centerHint {
    position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background: rgba(0,0,0,0.45); padding:8px 12px; border-radius:10px;
    color:var(--muted); font-size:13px; z-index:40;
  }
  @media (max-width:520px){
    .range{ width:96px; }
    .btn{ padding:6px 8px; font-size:13px; }
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="panel" id="leftPanel">
    <button class="btn" id="toggleAuto">Auto: ON</button>
    <div style="display:flex;align-items:center;">
      <span class="label">Rate</span>
      <input id="rate" class="range" type="range" min="0" max="3" step="0.05" value="1">
    </div>
    <div style="display:flex;align-items:center;">
      <span class="label">Power</span>
      <input id="power" class="range" type="range" min="0.6" max="1.6" step="0.05" value="1">
    </div>
  </div>

  <div class="panel" id="rightPanel">
    <div style="display:flex;align-items:center;">
      <span class="label">Fragments</span>
      <input id="pieces" class="range" type="range" min="8" max="140" step="1" value="40">
    </div>
    <button class="btn" id="clearBtn">Clear</button>
  </div>
</div>

<div class="centerHint" id="hint">탭/클릭으로 불꽃 터트리기 • 길게 누르면 연속 발사</div>

<script>
/*
  Fireworks — single HTML
  - mobile touch friendly
  - tap to spawn a firework at touch x,y (from bottom)
  - long press -> continuous stream
  - auto mode: random fireworks
  - UI controls: rate, power, pieces
  - optimized particle pooling, performant drawing
*/

// canvas + DPR
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width = Math.floor(innerWidth * DPR);
  canvas.height = Math.floor(innerHeight * DPR);
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize);
resize();

const W = ()=>innerWidth, H = ()=>innerHeight;

// settings (UI)
let autoOn = true;
const rateEl = document.getElementById('rate');
const powerEl = document.getElementById('power');
const piecesEl = document.getElementById('pieces');
const toggleAuto = document.getElementById('toggleAuto');
const clearBtn = document.getElementById('clearBtn');

toggleAuto.addEventListener('click', ()=>{ autoOn = !autoOn; toggleAuto.innerText = 'Auto: ' + (autoOn ? 'ON' : 'OFF'); });
clearBtn.addEventListener('click', ()=>{ // flush particles
  rockets.length = 0; particles.length = 0;
});

// utility
function rand(a,b){ return a + Math.random()*(b-a); }
function hsl(h,s,l){ return `hsl(${h} ${s}% ${l}%)`; }

// pooling arrays
const particles = [];
const rockets = [];

// Rocket (launcher) — rises then explodes
class Rocket {
  constructor(x, y, vx, vy, power){
    this.x = x; this.y = y; this.vx = vx; this.vy = vy;
    this.power = power;
    this.age = 0;
    this.exploded = false;
    this.hue = Math.floor(Math.random()*360);
    this.size = 3 + Math.random()*2;
    // trail
    this.trail = [];
  }
  update(dt){
    if(this.exploded) return;
    this.age += dt;
    // physics
    this.vy += 300 * dt; // gravity (positive down) so negative slows
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    // trail record
    this.trail.push({x:this.x, y:this.y});
    if(this.trail.length > 6) this.trail.shift();

    // explosion condition: height threshold or age
    const targetY = rand(H()*0.12, H()*0.45);
    if(this.vy > 0 || this.y <= targetY || this.age > 3.2){
      this.explode();
    }
  }
  explode(){
    if(this.exploded) return;
    this.exploded = true;
    const count = Math.floor(parseInt(piecesEl.value) || 40);
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      // different radial distribution: bias by power
      const sp = (0.5 + Math.random()*1.4) * (1 + (this.power-1)*0.9);
      const speed = sp * rand(80, 320) * (parseFloat(powerEl.value) || 1);
      const pvx = Math.cos(angle) * speed;
      const pvy = Math.sin(angle) * speed;
      const life = rand(0.8, 1.8);
      particles.push(new Particle(this.x, this.y, pvx, pvy, life, this.hue));
    }
    // small secondary "spark" burst
    const tiny = Math.floor(Math.random()*6);
    for(let t=0;t<tiny;t++){
      const a = Math.random()*Math.PI*2;
      particles.push(new Particle(this.x, this.y, Math.cos(a)*rand(20,120), Math.sin(a)*rand(20,120), rand(0.5,1.1), (this.hue+rand(-20,20))));
    }
  }
  draw(ctx){
    if(this.exploded) return;
    // trail
    for(let i=0;i<this.trail.length;i++){
      const p = this.trail[i];
      const a = i / this.trail.length;
      ctx.fillStyle = `rgba(255,255,255,${0.05 + 0.3*a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(1, this.size*(1-a)), 0, Math.PI*2);
      ctx.fill();
    }
    // rocket head
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.fill();
  }
}

// Particle (spark)
class Particle {
  constructor(x, y, vx, vy, life, hue){
    this.x = x; this.y = y;
    this.vx = vx; this.vy = vy;
    this.life = life;
    this.maxLife = life;
    this.hue = hue || Math.random()*360;
    this.size = 2 + Math.random()*3;
    this.drag = 0.995 - Math.random()*0.005;
    this.shrink = 0.98 - Math.random()*0.01;
    this.alpha = 1;
    this.spin = (Math.random()-0.5) * 6;
  }
  update(dt){
    this.life -= dt;
    if(this.life <= 0) return;
    // physics
    this.vy += 200 * dt; // gravity
    this.vx *= this.drag;
    this.vy *= this.drag;
    this.x += this.vx * dt;
    this.y += this.vy * dt;
    this.size *= this.shrink;
    this.alpha = Math.max(0, this.life / this.maxLife);
    this.hue += this.spin * dt * 10;
  }
  draw(ctx){
    if(this.life <= 0) return;
    // radial gradient glow
    const g = ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.size*5);
    g.addColorStop(0, `hsla(${this.hue},100%,60%,${0.8*this.alpha})`);
    g.addColorStop(0.4, `hsla(${this.hue},90%,55%,${0.35*this.alpha})`);
    g.addColorStop(1, `rgba(0,0,0,0)`);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size*5, 0, Math.PI*2);
    ctx.fill();

    // core
    ctx.fillStyle = `hsla(${this.hue},100%,65%,${this.alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, Math.max(0.5, this.size), 0, Math.PI*2);
    ctx.fill();
  }
}

// spawn rocket from bottom at x target (simulating launch toward point)
function spawnRocketAt(targetX, targetY, userPower){
  // start near bottom center-ish
  const startX = rand(innerWidth*0.2, innerWidth*0.8);
  const startY = innerHeight + 10;
  // velocity to aim near target with some randomness
  const dx = targetX - startX, dy = targetY - startY;
  const dist = Math.hypot(dx, dy);
  const speed = rand(420, 720) * (userPower || 1);
  const vx = dx / dist * speed;
  const vy = dy / dist * speed;
  const r = new Rocket(startX, startY, vx, vy, userPower || 1);
  rockets.push(r);
}

// user interaction: tap / long press
let pressTimer = null;
let isPressing = false;
let pressX = 0, pressY = 0;

function touchStart(x,y){
  isPressing = true;
  pressX = x; pressY = y;
  // immediate single shot
  spawnRocketAt(x,y, parseFloat(powerEl.value) || 1);
  // long press continuous
  pressTimer = setInterval(()=>{ if(isPressing) spawnRocketAt(pressX, pressY, parseFloat(powerEl.value) || 1); }, 220);
}
function touchEnd(){
  isPressing = false;
  if(pressTimer){ clearInterval(pressTimer); pressTimer = null; }
}

canvas.addEventListener('mousedown', e=>{ touchStart(e.clientX, e.clientY); });
canvas.addEventListener('mouseup', e=>{ touchEnd(); });
canvas.addEventListener('mouseleave', e=>{ touchEnd(); });

canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  const t = e.touches[0];
  touchStart(t.clientX, t.clientY);
}, {passive:false});
canvas.addEventListener('touchend', e=>{ touchEnd(); }, {passive:false});
canvas.addEventListener('touchcancel', e=>{ touchEnd(); }, {passive:false});

// auto mode: occasionally spawn random fireworks
let autoTimer = 0;

// animation loop
let last = performance.now();
function step(ts){
  const dt = Math.min(0.033, (ts - last)/1000);
  last = ts;

  // clear with slight alpha for trails glow
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgba(5,6,10,0.25)';
  ctx.fillRect(0,0,innerWidth, innerHeight);

  // update rockets
  for(let i = rockets.length-1; i>=0; i--){
    const r = rockets[i];
    r.update(dt);
    if(r.exploded){
      rockets.splice(i,1);
    }
  }

  // update particles
  for(let i = particles.length-1; i>=0; i--){
    const p = particles[i];
    p.update(dt);
    if(p.life <= 0 || p.size < 0.2){
      particles.splice(i,1);
    }
  }

  // draw: additive for glow
  ctx.globalCompositeOperation = 'lighter';
  for(const p of particles) p.draw(ctx);
  for(const r of rockets) r.draw(ctx);
  ctx.globalCompositeOperation = 'source-over';

  // auto spawn logic using rate slider (0..3)
  if(autoOn){
    autoTimer += dt * (parseFloat(rateEl.value) || 1);
    // random threshold
    while(autoTimer > 0.6){
      autoTimer -= 0.6;
      const x = rand(innerWidth*0.1, innerWidth*0.9);
      const y = rand(innerHeight*0.15, innerHeight*0.55);
      spawnRocketAt(x, y, parseFloat(powerEl.value) || 1);
    }
  }

  requestAnimationFrame(step);
}
requestAnimationFrame(step);

// Nice initial burst
(function introBurst(){
  for(let i=0;i<6;i++){
    setTimeout(()=> spawnRocketAt(rand(innerWidth*0.2, innerWidth*0.8), rand(innerHeight*0.12, innerHeight*0.35), rand(0.9,1.3)), i*250);
  }
})();

</script>
</body>
</html>
