<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>patrol</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #0f172a;
    height: 100%;
  }
  canvas {
    display: block;
    background: #1e293b;
    touch-action: none;
  }
  /* 조이스틱 */
  .joystick {
    position: fixed;
    bottom: 5%;
    left: 10%;
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: rgba(255,255,255,0.05);
    border: 2px solid rgba(255,255,255,0.1);
    touch-action: none;
  }
  .stick {
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.25);
    border-radius: 50%;
    position: absolute;
    top: 30px;
    left: 30px;
  }
  #msg {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 3rem;
    background: rgba(0,0,0,0.8);
    z-index: 10;
    opacity: 0;
    transition: opacity 0.5s;
  }
  #msg.show { opacity: 1; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="msg">GAME OVER</div>
<div class="joystick" id="joystick"><div class="stick" id="stick"></div></div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;

const TILE = 48;
const COLS = 20, ROWS = 14;
let grid = [];
const player = { x: 0, y: 0, r: 14, spd: 2.6, dir: 0, fov: 120, range: 220 };
const enemy = { x: 0, y: 0, r: 16, spd: 1.6, dir: 0, fov: 100, range: 240, chase: false };

function genMap() {
  grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  // 테두리
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (x === 0 || y === 0 || x === COLS - 1 || y === ROWS - 1) grid[y][x] = 1;
      else if (Math.random() < 0.18) grid[y][x] = 1;
    }
  }
  // 통로 확보
  for (let i = 0; i < 25; i++) {
    const rx = Math.floor(Math.random() * COLS);
    const ry = Math.floor(Math.random() * ROWS);
    for (let dy = -1; dy <= 1; dy++)
      for (let dx = -1; dx <= 1; dx++) {
        const nx = rx + dx, ny = ry + dy;
        if (nx > 0 && ny > 0 && nx < COLS - 1 && ny < ROWS - 1)
          grid[ny][nx] = 0;
      }
  }
}

function tileToWorld(tx, ty) {
  return { x: tx * TILE + TILE / 2, y: ty * TILE + TILE / 2 };
}

function worldToTile(x, y) {
  return { tx: Math.floor(x / TILE), ty: Math.floor(y / TILE) };
}

function collide(x, y, r) {
  const { tx, ty } = worldToTile(x, y);
  for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
    const xx = tx + dx, yy = ty + dy;
    if (xx < 0 || yy < 0 || xx >= COLS || yy >= ROWS) continue;
    if (grid[yy][xx]) {
      const rx = xx * TILE, ry = yy * TILE;
      const testX = Math.max(rx, Math.min(x, rx + TILE));
      const testY = Math.max(ry, Math.min(y, ry + TILE));
      const dx0 = x - testX, dy0 = y - testY;
      if (dx0 * dx0 + dy0 * dy0 < r * r) return true;
    }
  }
  return false;
}

function randomSpawn(entity) {
  let tries = 0;
  while (tries < 300) {
    const tx = Math.floor(Math.random() * COLS);
    const ty = Math.floor(Math.random() * ROWS);
    if (grid[ty][tx] === 0) {
      const { x, y } = tileToWorld(tx, ty);
      if (!collide(x, y, entity.r)) {
        entity.x = x; entity.y = y;
        return;
      }
    }
    tries++;
  }
}

function rayBlocked(ax, ay, bx, by, step = 8) {
  const dx = bx - ax, dy = by - ay;
  const len = Math.hypot(dx, dy);
  const nx = dx / len, ny = dy / len;
  for (let t = 0; t < len; t += step) {
    const px = ax + nx * t, py = ay + ny * t;
    const { tx, ty } = worldToTile(px, py);
    if (tx < 0 || ty < 0 || tx >= COLS || ty >= ROWS) return true;
    if (grid[ty][tx]) return true;
  }
  return false;
}

genMap();
randomSpawn(player);
randomSpawn(enemy);

let move = { x: 0, y: 0 }, dragging = false;

// 모바일 조이스틱
const joy = document.getElementById('joystick');
const stick = document.getElementById('stick');
joy.addEventListener('touchstart', e => { dragging = true; e.preventDefault(); });
joy.addEventListener('touchmove', e => {
  if (!dragging) return;
  const t = e.touches[0];
  const rect = joy.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const dx = t.clientX - cx;
  const dy = t.clientY - cy;
  const dist = Math.min(40, Math.hypot(dx, dy));
  const ang = Math.atan2(dy, dx);
  stick.style.transform = `translate(${Math.cos(ang) * dist}px, ${Math.sin(ang) * dist}px)`;
  move.x = Math.cos(ang) * (dist / 40);
  move.y = Math.sin(ang) * (dist / 40);
  player.dir = ang * 180 / Math.PI;
}, { passive: false });
joy.addEventListener('touchend', e => {
  dragging = false;
  stick.style.transform = 'translate(0,0)';
  move = { x: 0, y: 0 };
});

function update() {
  const nx = player.x + move.x * player.spd;
  const ny = player.y + move.y * player.spd;
  if (!collide(nx, player.y, player.r)) player.x = nx;
  if (!collide(player.x, ny, player.r)) player.y = ny;

  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const dist = Math.hypot(dx, dy);
  const ang = Math.atan2(dy, dx);
  enemy.dir = ang * 180 / Math.PI;
  const sees = dist < enemy.range && !rayBlocked(enemy.x, enemy.y, player.x, player.y);

  if (sees) {
    enemy.chase = true;
    enemy.spd = 4.5;
  } else {
    enemy.chase = false;
    enemy.spd = 1.5;
  }

  if (enemy.chase) {
    const gx = enemy.x + Math.cos(ang) * enemy.spd;
    const gy = enemy.y + Math.sin(ang) * enemy.spd;
    if (!collide(gx, gy, enemy.r)) {
      enemy.x = gx; enemy.y = gy;
    }
  }

  if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.r + enemy.r) {
    document.getElementById('msg').classList.add('show');
  }
}

function draw() {
  ctx.clearRect(0, 0, W, H);
  const offsetX = W / 2 - player.x;
  const offsetY = H / 2 - player.y;
  ctx.save();
  ctx.translate(offsetX, offsetY);

  // 맵
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (grid[y][x]) {
        ctx.fillStyle = '#475569';
        ctx.fillRect(x * TILE, y * TILE, TILE, TILE);
      }
    }
  }

  // 적 시야
  ctx.beginPath();
  ctx.moveTo(enemy.x, enemy.y);
  const fov = enemy.fov * Math.PI / 180;
  const a1 = enemy.dir * Math.PI / 180 - fov / 2;
  const a2 = enemy.dir * Math.PI / 180 + fov / 2;
  ctx.arc(enemy.x, enemy.y, enemy.range, a1, a2);
  ctx.closePath();
  ctx.fillStyle = "rgba(255, 100, 100, 0.15)";
  ctx.fill();

  // 적
  ctx.fillStyle = enemy.chase ? "#f87171" : "#ef4444";
  ctx.beginPath();
  ctx.arc(enemy.x, enemy.y, enemy.r, 0, Math.PI * 2);
  ctx.fill();

  // 플레이어
  ctx.fillStyle = "#34d399";
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
  ctx.fill();

  // 플레이어 시야 마스크
  const grad = ctx.createRadialGradient(player.x, player.y, player.range * 0.3, player.x, player.y, player.range);
  grad.addColorStop(0, "rgba(0,0,0,0)");
  grad.addColorStop(1, "rgba(0,0,0,0.95)");
  ctx.fillStyle = grad;
  ctx.fillRect(-offsetX, -offsetY, W, H);

  ctx.restore();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

window.addEventListener('resize', () => {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
});
</script>
</body>
</html>
