<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>patrol</title>
<style>
:root{
  --bg:#05060a; --floor:#0b0f14; --wall:#2b2f33; --player:#a7f3d0; --enemy:#fb7185;
  --accent:#f97316;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;-webkit-tap-highlight-color: transparent;font-family:Inter,system-ui,Arial}
canvas{display:block;width:100vw;height:100vh;background:var(--floor);touch-action:none}
.header {
  position:fixed; left:12px; top:10px; z-index:60; color:#fff; font-weight:600;
  background:rgba(0,0,0,0.2); padding:6px 10px; border-radius:8px; backdrop-filter: blur(6px);
}
.joystick {
  position: fixed;
  left: 14px;
  bottom: 14px;
  width: 120px; height:120px;
  border-radius:50%;
  background: rgba(255,255,255,0.03);
  border: 2px solid rgba(255,255,255,0.04);
  z-index:50; touch-action:none;
}
.stick {
  position:absolute; left:34px; top:34px;
  width:52px; height:52px; border-radius:50%;
  background: rgba(255,255,255,0.14);
  transition: transform 0.02s linear; touch-action:none;
}
.msg {
  position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:70;
  pointer-events:none; opacity:0; transition:opacity .2s;
  color:#fff; text-align:center; font-size:20px;
}
.msg.show{opacity:1; pointer-events:auto; background:rgba(0,0,0,0.6)}
.controls {
  position:fixed; right:12px; top:10px; z-index:60; display:flex; gap:8px;
}
.btn {
  background:rgba(255,255,255,0.06); color:#fff; border-radius:10px; padding:6px 10px;
  border:1px solid rgba(255,255,255,0.03); cursor:pointer; font-size:13px;
}
.legend {
  position:fixed; left:12px; bottom:150px; z-index:60; color:#fff; opacity:0.7; font-size:12px;
}

/* responsive */
@media (max-width:420px){
  .joystick{width:92px;height:92px}
  .stick{left:24px;top:24px;width:44px;height:44px}
  .legend{bottom:120px}
}
</style>
</head>
<body>
<div class="header">Backroom Stealth</div>
<div class="controls">
  <button class="btn" id="btnReset">리셋</button>
  <button class="btn" id="btnToggleFps">FPS</button>
</div>
<div class="joystick" id="joy" aria-hidden="true"><div class="stick" id="stick"></div></div>
<div class="legend">조이스틱으로 이동 · 플레이어는 화면 중앙</div>
<div class="msg" id="msg">발견됨! 화면 탭으로 재시작</div>
<canvas id="c"></canvas>

<script>
/*
  Backroom Stealth — Single-file
  Features:
  - Mobile joystick movement
  - Random connected tile map (rooms/corridors)
  - Wall collision
  - Enemy AI: patrol waypoints + A* chase (pathfinding)
  - Player FOV (앞 120°만 보임), 어둠 오버레이 (벽에 의해 가려짐)
  - Safe spawn logic
  - Gameover on contact, restart by tap
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: false });
let W = innerWidth, H = innerHeight;
canvas.width = W; canvas.height = H;

const TILE = 48;           // tile size in px
const COLS = 20, ROWS = 14; // grid size: adjust for difficulty/feel
const MAP_W = COLS * TILE, MAP_H = ROWS * TILE;

// grid: 0 free, 1 wall
let grid = [];

/* ---------- map generation + connectivity ---------- */
function generateMap(){
  grid = Array.from({length: ROWS}, ()=>Array.from({length: COLS}, ()=>0));
  // outer walls
  for(let x=0;x<COLS;x++){ grid[0][x]=1; grid[ROWS-1][x]=1; }
  for(let y=0;y<ROWS;y++){ grid[y][0]=1; grid[y][COLS-1]=1; }

  // random interior walls — create dense, then carve rooms/corridors
  for(let y=1;y<ROWS-1;y++){
    for(let x=1;x<COLS-1;x++){
      grid[y][x] = Math.random() < 0.26 ? 1 : 0;
    }
  }

  // carve several rooms (clear small areas)
  for(let i=0;i<28;i++){
    const rx = randInt(2, COLS-3);
    const ry = randInt(2, ROWS-3);
    for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++){
      const nx = rx+dx, ny = ry+dy;
      if(nx>0 && ny>0 && nx<COLS-1 && ny<ROWS-1) grid[ny][nx] = 0;
    }
  }

  // ensure connectivity: flood-fill from center free tile; carve corridors if needed
  ensureConnectivity();
}

function ensureConnectivity(){
  const visited = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
  // find a free start
  let sx = Math.floor(COLS/2), sy = Math.floor(ROWS/2);
  if(grid[sy][sx] === 1){
    outer: for(let r=1;r<Math.max(COLS,ROWS);r++){
      for(let dy=-r;dy<=r;dy++) for(let dx=-r;dx<=r;dx++){
        const nx=sx+dx, ny=sy+dy;
        if(nx>0 && ny>0 && nx<COLS-1 && ny<ROWS-1 && grid[ny][nx]===0){ sx=nx; sy=ny; break outer; }
      }
    }
  }
  const stack = [[sx,sy]];
  while(stack.length){
    const [x,y] = stack.pop();
    if(visited[y][x]) continue;
    visited[y][x] = true;
    for(const d of [[1,0],[-1,0],[0,1],[0,-1]]){
      const nx = x + d[0], ny = y + d[1];
      if(nx>0 && ny>0 && nx<COLS-1 && ny<ROWS-1 && !visited[ny][nx] && grid[ny][nx]===0) stack.push([nx,ny]);
    }
  }
  // carve straight corridors to connect isolated free tiles to visited region
  for(let y=1;y<ROWS-1;y++) for(let x=1;x<COLS-1;x++){
    if(grid[y][x]===0 && !visited[y][x]){
      let cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
      let tx = x, ty = y;
      while(tx !== cx || ty !== cy){
        if(tx < cx) tx++;
        else if(tx > cx) tx--;
        if(ty < cy) ty++;
        else if(ty > cy) ty--;
        if(tx>0 && ty>0 && tx<COLS-1 && ty<ROWS-1) grid[ty][tx] = 0;
      }
    }
  }
}

/* ---------- helpers ---------- */
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function tileToWorld(tx,ty){ return { x: tx*TILE + TILE/2, y: ty*TILE + TILE/2 }; }
function worldToTile(wx,wy){ return { tx: Math.floor(wx / TILE), ty: Math.floor(wy / TILE) }; }

/* circle vs tile rect collision */
function collidesWallAt(x,y,rad){
  const t = worldToTile(x,y);
  for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++){
    const tx = t.tx + dx, ty = t.ty + dy;
    if(tx<0||ty<0||tx>=COLS||ty>=ROWS) continue;
    if(grid[ty][tx]===1){
      const rx = tx*TILE, ry = ty*TILE;
      const closestX = Math.max(rx, Math.min(x, rx+TILE));
      const closestY = Math.max(ry, Math.min(y, ry+TILE));
      const dx0 = x - closestX, dy0 = y - closestY;
      if(dx0*dx0 + dy0*dy0 < rad*rad) return true;
    }
  }
  return false;
}

/* raycast: returns true if blocked by wall */
function rayBlocked(ax,ay,bx,by,step=6){
  const dx = bx-ax, dy = by-ay;
  const L = Math.hypot(dx,dy);
  if(L === 0) return false;
  const nx = dx/L, ny = dy/L;
  let t = 0;
  while(t < L){
    const px = ax + nx*t, py = ay + ny*t;
    const { tx, ty } = worldToTile(px,py);
    if(tx<0||ty<0||tx>=COLS||ty>=ROWS) return true;
    if(grid[ty][tx] === 1) return true;
    t += step;
  }
  return false;
}

/* ---------- pathfinding A* ---------- */
function findPath(sx,sy,tx,ty){
  const key = (x,y)=>`${x}_${y}`;
  const start = {x:sx,y:sy};
  const goal = {x:tx,y:ty};
  const open = [start];
  const came = {};
  const g = {}; const f = {};
  g[key(sx,sy)] = 0; f[key(sx,sy)] = heuristic(sx,sy,tx,ty);
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  while(open.length){
    open.sort((a,b)=>f[key(a.x,a.y)] - f[key(b.x,b.y)]);
    const cur = open.shift();
    if(cur.x === goal.x && cur.y === goal.y){
      // reconstruct path (exclude starting tile)
      const path = [];
      let k = key(cur.x,cur.y);
      while(came[k]){
        const [px,py] = k.split('_').map(n=>parseInt(n));
        path.unshift({tx:px, ty:py});
        k = came[k];
      }
      return path;
    }
    for(const d of dirs){
      const nx = cur.x + d[0], ny = cur.y + d[1];
      if(nx<0||ny<0||nx>=COLS||ny>=ROWS) continue;
      if(grid[ny][nx]===1) continue;
      const nk = key(nx,ny);
      const ng = g[key(cur.x,cur.y)] + 1;
      if(g[nk] === undefined || ng < g[nk]){
        g[nk] = ng;
        f[nk] = ng + heuristic(nx,ny,tx,ty);
        came[nk] = key(cur.x,cur.y);
        if(!open.find(o=>o.x===nx && o.y===ny)) open.push({x:nx,y:ny});
      }
    }
  }
  return []; // no path
}
function heuristic(x1,y1,x2,y2){ return Math.abs(x1-x2) + Math.abs(y1-y2); }

/* ---------- entities ---------- */
const player = { x:0, y:0, r:14, speed:2.6, dir: -90, fov:120, range:220 };
const guards = []; // multiple guards

/* generate guards with patrol waypoints */
function setupGuards(){
  guards.length = 0;
  const preset = [
    [{tx:3,ty:2},{tx:8,ty:2},{tx:8,ty:5},{tx:3,ty:5}],
    [{tx:14,ty:2},{tx:17,ty:2},{tx:17,ty:5},{tx:14,ty:5}],
    [{tx:10,ty:9},{tx:6,ty:9},{tx:6,ty:11}],
  ];
  // for each preset that fits in map and is free, create guard; otherwise create random patrol points
  for(let i=0;i<3;i++){
    let wps = preset[i].filter(p=>p.tx>0 && p.ty>0 && p.tx<COLS-1 && p.ty<ROWS-1);
    if(Math.random() < 0.5){
      // random waypoints near center
      wps = [];
      const cnt = randInt(2,4);
      for(let k=0;k<cnt;k++){
        wps.push({ tx: randInt(2,COLS-3), ty: randInt(2,ROWS-3) });
      }
    }
    // ensure waypoints are on free tiles; if not, adjust
    wps = wps.map(w=>{
      if(grid[w.ty][w.tx] === 1){
        // find nearest free around it
        for(let r=1;r<6;r++){
          outer: for(let dy=-r;dy<=r;dy++) for(let dx=-r;dx<=r;dx++){
            const nx = w.tx+dx, ny = w.ty+dy;
            if(nx>0 && ny>0 && nx<COLS-1 && ny<ROWS-1 && grid[ny][nx]===0){ w.tx=nx; w.ty=ny; break outer;}
          }
          if(grid[w.ty][w.tx]===0) break;
        }
      }
      return w;
    });
    const wp0 = wps[0];
    const w0 = tileToWorld(wp0.tx, wp0.ty);
    guards.push({
      waypoints: wps,
      ti: 0,
      x: w0.x, y: w0.y,
      r: 14,
      speed: 1.3 + Math.random()*0.6,
      fov: 90 + Math.random()*40,
      range: 180 + Math.random()*80,
      state: 'patrol',
      path: [],
      pathStep: 0,
      pathTimer: 0,
      fwd: undefined
    });
  }
}

/* safe spawn */
function spawnPlayer(){
  // place near center if possible
  const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
  // search outward for free tile
  for(let r=0;r<Math.max(COLS,ROWS);r++){
    for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++){
      const nx = cx + dx, ny = cy + dy;
      if(nx>0 && ny>0 && nx<COLS-1 && ny<ROWS-1 && grid[ny][nx]===0){
        const w = tileToWorld(nx,ny);
        if(!collidesWallAt(w.x,w.y, player.r)){
          player.x = w.x; player.y = w.y; return true;
        }
      }
    }
  }
  return false;
}
function ensureGuardsNotInWall(){
  for(const g of guards){
    const t = worldToTile(g.x,g.y);
    if(grid[t.ty][t.tx]===1 || collidesWallAt(g.x,g.y,g.r)){
      // relocate to first waypoint safe spot
      let placed = false;
      for(const wp of g.waypoints){
        const w = tileToWorld(wp.tx, wp.ty);
        if(!collidesWallAt(w.x,w.y,g.r)){ g.x = w.x; g.y = w.y; placed = true; break; }
      }
      if(!placed){
        // find any free tile
        outer:
        for(let y=1;y<ROWS-1;y++) for(let x=1;x<COLS-1;x++){
          if(grid[y][x]===0){
            const w = tileToWorld(x,y);
            if(!collidesWallAt(w.x,w.y,g.r)){ g.x=w.x; g.y=w.y; break outer; }
          }
        }
      }
    }
  }
}

/* ---------- GUARD AI (patrol + A* chase) ---------- */
function updateGuard(g){
  // check detection (in FOV & not blocked)
  const dx = player.x - g.x, dy = player.y - g.y;
  const dist = Math.hypot(dx,dy);
  // determine facing from movement or waypoint
  if(!g.fwd){
    const w0 = g.waypoints[g.ti];
    const w1 = g.waypoints[(g.ti+1)%g.waypoints.length];
    const w0w = tileToWorld(w0.tx,w0.ty), w1w = tileToWorld(w1.tx,w1.ty);
    g.fwd = Math.atan2(w1w.y - w0w.y, w1w.x - w0w.x);
  }
  const facing = g.fwd;
  const angToPlayer = Math.atan2(dy,dx);
  let diff = Math.abs(((angToPlayer - facing + Math.PI) % (2*Math.PI)) - Math.PI);
  const inFov = (diff * 180/Math.PI) <= (g.fov/2) && dist <= g.range;
  const blocked = rayBlocked(g.x,g.y,player.x,player.y,6);
  const sees = inFov && !blocked;

  // state transitions
  if(sees){
    if(g.state !== 'chase'){
      g.state = 'chase';
      // compute path from current tile to player tile
      const s = worldToTile(g.x,g.y), p = worldToTile(player.x,player.y);
      g.path = findPath(s.tx, s.ty, p.tx, p.ty);
      g.pathStep = 0;
      g.pathTimer = 0;
    } else {
      // occasionally recompute path
      if(++g.pathTimer > 18){
        const s = worldToTile(g.x,g.y), p = worldToTile(player.x,player.y);
        g.path = findPath(s.tx, s.ty, p.tx, p.ty);
        g.pathStep = 0; g.pathTimer = 0;
      }
    }
  } else {
    if(g.state === 'chase'){
      g.state = 'search';
      g.searchTicks = 100 + Math.floor(Math.random()*80);
    } else if(g.state === 'search'){
      g.searchTicks--;
      if(g.searchTicks <= 0){ g.state = 'patrol'; g.path=[]; g.pathStep=0; }
    }
  }

  // movement by state
  if(g.state === 'patrol'){
    const curWp = g.waypoints[g.ti];
    const target = tileToWorld(curWp.tx, curWp.ty);
    const vx = target.x - g.x, vy = target.y - g.y;
    const d = Math.hypot(vx,vy);
    if(d < 6){
      g.ti = (g.ti + 1) % g.waypoints.length;
      // update facing to next
      const nextWp = g.waypoints[g.ti];
      const nw = tileToWorld(nextWp.tx,nextWp.ty);
      g.fwd = Math.atan2(nw.y - target.y, nw.x - target.x);
    } else {
      const nx = g.x + (vx/d) * g.speed;
      const ny = g.y + (vy/d) * g.speed;
      if(!collidesWallAt(nx,ny,g.r)){ g.x = nx; g.y = ny; }
      // update facing toward movement
      if(d>1) g.fwd = Math.atan2(vy, vx);
    }
  } else if(g.state === 'chase' && g.path && g.path.length){
    const step = g.path[g.pathStep];
    if(!step){
      g.path = [];
    } else {
      const target = tileToWorld(step.tx, step.ty);
      const vx = target.x - g.x, vy = target.y - g.y;
      const d = Math.hypot(vx,vy);
      if(d < 6){
        g.pathStep++;
        if(g.pathStep >= g.path.length){ g.path = []; }
      } else {
        const nx = g.x + (vx/d) * g.speed * 1.2;
        const ny = g.y + (vy/d) * g.speed * 1.2;
        if(!collidesWallAt(nx,ny,g.r)){ g.x = nx; g.y = ny; }
        g.fwd = Math.atan2(vy, vx);
      }
    }
  } else if(g.state === 'search'){
    // small jitter movement
    const nx = g.x + (Math.random()-0.5)*0.6;
    const ny = g.y + (Math.random()-0.5)*0.6;
    if(!collidesWallAt(nx,ny,g.r)){ g.x = nx; g.y = ny; }
  }
}

/* ---------- joystick control ---------- */
const joy = document.getElementById('joy'), stick = document.getElementById('stick');
let dragging = false;
let move = { x:0, y:0 };
joy.addEventListener('touchstart', e => { dragging = true; e.preventDefault(); }, { passive:false });
joy.addEventListener('touchmove', e => {
  if(!dragging) return;
  const t = e.touches[0];
  const rect = joy.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  const dx = t.clientX - cx, dy = t.clientY - cy;
  const dist = Math.min(Math.hypot(dx,dy), 40);
  const ang = Math.atan2(dy,dx);
  const tx = Math.cos(ang)*dist, ty = Math.sin(ang)*dist;
  stick.style.transform = `translate(${tx}px, ${ty}px)`;
  move.x = Math.cos(ang)*(dist/40); move.y = Math.sin(ang)*(dist/40);
  player.dir = ang * 180/Math.PI;
  e.preventDefault();
}, { passive:false });
joy.addEventListener('touchend', e => { dragging=false; stick.style.transform='translate(0,0)'; move.x=0; move.y=0; }, { passive:false });
// mouse support
joy.addEventListener('mousedown', e=>{
  dragging=true;
  const moveFn = ev => {
    if(!dragging) return;
    const rect = joy.getBoundingClientRect();
    const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
    const dx = ev.clientX - cx, dy = ev.clientY - cy;
    const dist = Math.min(Math.hypot(dx,dy), 40);
    const ang = Math.atan2(dy,dx);
    const tx = Math.cos(ang)*dist, ty = Math.sin(ang)*dist;
    stick.style.transform = `translate(${tx}px, ${ty}px)`;
    move.x = Math.cos(ang)*(dist/40); move.y = Math.sin(ang)*(dist/40);
    player.dir = ang * 180/Math.PI;
  };
  const upFn = ()=>{ dragging=false; stick.style.transform='translate(0,0)'; move.x=0; move.y=0; window.removeEventListener('mousemove', moveFn); window.removeEventListener('mouseup', upFn); };
  window.addEventListener('mousemove', moveFn);
  window.addEventListener('mouseup', upFn);
});

/* ---------- drawing utilities ---------- */
function drawMap(camX, camY){
  // floor
  ctx.fillStyle = '#071018';
  ctx.fillRect(camX, camY, MAP_W, MAP_H);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(grid[y][x]===1){
        const rx = x*TILE + camX, ry = y*TILE + camY;
        // wall tile style (backroom vibe)
        ctx.fillStyle = '#2b2f33';
        ctx.fillRect(rx, ry, TILE, TILE);
        // subtle lines
        ctx.strokeStyle = 'rgba(0,0,0,0.16)';
        ctx.strokeRect(rx+1, ry+1, TILE-2, TILE-2);
      }
    }
  }
}

/* draw FOV polygon using raycasts to respect walls */
function drawVision(worldX, worldY, dirDeg, fovDeg, range, intensity=1){
  const sx = W/2 + (worldX - player.x);
  const sy = H/2 + (worldY - player.y);
  const a0 = (dirDeg - fovDeg/2) * Math.PI/180;
  const a1 = (dirDeg + fovDeg/2) * Math.PI/180;
  ctx.beginPath();
  ctx.moveTo(sx, sy);
  const steps = 48;
  for(let i=0;i<=steps;i++){
    const a = a0 + (a1 - a0) * (i/steps);
    let ex = worldX + Math.cos(a) * range;
    let ey = worldY + Math.sin(a) * range;
    for(let d=0; d<range; d+=6){
      const wx = worldX + Math.cos(a) * d;
      const wy = worldY + Math.sin(a) * d;
      const { tx, ty } = worldToTile(wx, wy);
      if(tx<0||ty<0||tx>=COLS||ty>=ROWS || grid[ty][tx]===1){
        ex = wx; ey = wy; break;
      }
    }
    const screenX = W/2 + (ex - player.x);
    const screenY = H/2 + (ey - player.y);
    ctx.lineTo(screenX, screenY);
  }
  ctx.closePath();
  const g = ctx.createRadialGradient(sx, sy, 0, sx, sy, range);
  g.addColorStop(0, `rgba(255,255,255,${0.9*intensity})`);
  g.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = g;
  ctx.fill();
}

/* ---------- game state + loop ---------- */
let detected = false;
const msgEl = document.getElementById('msg');
let fpsOn = false;
let lastTime = performance.now();
let fps = 0;

function reset(){
  detected = false;
  msgEl.classList.remove('show');
  generateMap();
  setupGuards();
  spawnPlayer();
  ensureGuardsNotInWall();
}

/* update guards and player */
function update(dt){
  if(detected) return;
  // move player with joystick, tile collision
  const nx = player.x + move.x * player.speed;
  const ny = player.y + move.y * player.speed;
  if(!collidesWallAt(nx, player.y, player.r)) player.x = nx;
  if(!collidesWallAt(player.x, ny, player.r)) player.y = ny;

  // update guards
  for(const g of guards) updateGuard(g);

  // detection check (guards see player)
  for(const g of guards){
    const dx = player.x - g.x, dy = player.y - g.y;
    const dist = Math.hypot(dx,dy);
    if(dist > g.range) continue;
    // compute guard facing angle
    let facing = g.fwd || 0;
    // angle to player
    const angToPlayer = Math.atan2(dy, dx);
    let diff = Math.abs(((angToPlayer - facing + Math.PI) % (2*Math.PI)) - Math.PI);
    const inFov = (diff * 180/Math.PI) <= (g.fov/2);
    const blocked = rayBlocked(g.x,g.y,player.x,player.y,6);
    if(inFov && !blocked){
      detected = true;
      msgEl.innerHTML = '발견됨! 화면을 탭하여 재시작';
      msgEl.classList.add('show');
      break;
    }
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  // camera such that player is centered
  const camX = (W/2) - player.x;
  const camY = (H/2) - player.y;

  // draw map and entities in world-space translated by camera
  drawMap(camX, camY);

  // draw guards (behind fog)
  for(const g of guards){
    // guard body
    ctx.beginPath();
    ctx.arc(camX + g.x, camY + g.y, g.r, 0, Math.PI*2);
    ctx.fillStyle = '#ef4444';
    ctx.fill();
    // small facing indicator
    const fx = g.x + Math.cos(g.fwd || 0) * (g.r + 6);
    const fy = g.y + Math.sin(g.fwd || 0) * (g.r + 6);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.moveTo(camX + g.x, camY + g.y); ctx.lineTo(camX + fx, camY + fy); ctx.stroke();
  }

  // player
  ctx.beginPath(); ctx.arc(W/2, H/2, player.r, 0, Math.PI*2);
  ctx.fillStyle = '#a7f3d0'; ctx.fill();
  // small player facing marker
  const pdx = Math.cos(player.dir * Math.PI/180) * (player.r+6);
  const pdy = Math.sin(player.dir * Math.PI/180) * (player.r+6);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.beginPath();
  ctx.moveTo(W/2, H/2); ctx.lineTo(W/2 + pdx, H/2 + pdy); ctx.stroke();

  // overlay darkness and carve out player's FOV (front 120° visible; others dark)
  ctx.fillStyle = 'rgba(0,0,0,0.92)';
  ctx.fillRect(0,0,W,H);

  // carve player's FOV
  ctx.save();
  ctx.globalCompositeOperation = 'destination-out';
  drawVision(player.x, player.y, player.dir, player.fov, player.range, 1.0);
  // small ambient around player so immediate feet area visible
  const s = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, 48);
  s.addColorStop(0, 'rgba(255,255,255,0.6)');
  s.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = s;
  ctx.beginPath(); ctx.arc(W/2, H/2, 48, 0, Math.PI*2); ctx.fill();

  // optionally, show guards' FOV faintly (for tension) but still obey walls
  ctx.globalCompositeOperation = 'destination-out';
  for(const g of guards){
    drawVision(g.x, g.y, (g.fwd || 0) * 180/Math.PI, g.fov, g.range * 0.7, 0.18);
  }

  ctx.restore();

  // top-left HUD: distance to nearest guard (for feel)
  let nearest = Infinity;
  for(const g of guards) nearest = Math.min(nearest, Math.hypot(player.x-g.x, player.y-g.y));
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = '13px Inter, Arial'; ctx.textAlign='left';
  ctx.fillText(`Nearest: ${Math.floor(nearest)}px`, 12, 30);

  if(fpsOn){
    ctx.fillText(`FPS: ${Math.round(fps)}`, 12, 50);
  }
}

/* ---------- main loop ---------- */
let last = performance.now();
function loop(now){
  const dt = (now - last) / 1000;
  last = now;
  // fps calc
  fps = 0.9 * fps + 0.1 * (1 / Math.max(dt, 1e-6));
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- interactions ---------- */
canvas.addEventListener('touchstart', e=>{
  if(msgEl.classList.contains('show')) { reset(); }
}, {passive:true});
canvas.addEventListener('mousedown', e=>{
  if(msgEl.classList.contains('show')) { reset(); }
});

document.getElementById('btnReset').addEventListener('click', ()=> reset());
document.getElementById('btnToggleFps').addEventListener('click', ()=> { fpsOn = !fpsOn; });

/* ---------- init ---------- */
generateMap();
setupGuards();
spawnPlayer();
ensureGuardsNotInWall();
requestAnimationFrame(loop);

/* expose for debug */
window._backroom = { player, guards, grid, reset };

</script>
</body>
</html>
